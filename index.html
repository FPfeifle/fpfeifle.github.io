<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Water Reflection Simulator</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Rajdhani:wght@300;400;600&display=swap');

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg:        #07090f;
    --panel:     #0a1520;
    --border:    #111820;
    --accent:    #1a5570;
    --label:     #88bbdd;
    --val:       #66aacc;
    --btn-hover: #182838;
    --wall-col:  #ff2244;
    --emit-col:  #00eeff;
  }

  body {
    background: var(--bg);
    color: var(--label);
    font-family: 'Rajdhani', sans-serif;
    font-weight: 400;
    display: flex;
    height: 100vh;
    overflow: hidden;
    gap: 0;
  }

  #canvas-wrap {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 8px 6px 6px 8px;
    min-width: 0;
    position: relative;
  }

  #canvas-title {
    color: var(--label);
    font-size: 11px;
    letter-spacing: 2px;
    text-transform: uppercase;
    margin-bottom: 4px;
    font-family: 'Share Tech Mono', monospace;
    opacity: 0.7;
  }

  #canvas-container {
    flex: 1;
    position: relative;
    overflow: hidden;
    border: 1px solid var(--border);
  }

  #sim-canvas, #overlay-canvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: block;
  }

  #sim-canvas  { cursor: crosshair; }
  #overlay-canvas { pointer-events: none; }

  #hint {
    font-size: 9px;
    color: #2a3a4a;
    margin-top: 4px;
    font-family: 'Share Tech Mono', monospace;
    letter-spacing: 0.5px;
  }

  #panel {
    width: 220px;
    min-width: 220px;
    background: var(--bg);
    border-left: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    padding: 8px 10px 8px 10px;
    gap: 6px;
    overflow-y: auto;
    overflow-x: hidden;
  }

  .panel-section {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 3px;
    padding: 8px 10px;
  }

  .section-title {
    font-size: 9px;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: #3a5a70;
    margin-bottom: 8px;
    font-family: 'Share Tech Mono', monospace;
  }

  .slider-row {
    display: flex;
    align-items: center;
    margin-bottom: 7px;
    gap: 6px;
  }
  .slider-row:last-child { margin-bottom: 0; }

  .slider-label {
    font-size: 10px;
    color: var(--label);
    width: 72px;
    flex-shrink: 0;
    font-family: 'Share Tech Mono', monospace;
    letter-spacing: 0.3px;
  }

  .slider-row input[type=range] {
    flex: 1;
    height: 3px;
    -webkit-appearance: none;
    appearance: none;
    background: var(--accent);
    border-radius: 2px;
    outline: none;
    cursor: pointer;
  }
  .slider-row input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 10px; height: 10px;
    border-radius: 50%;
    background: var(--val);
    cursor: pointer;
    border: 1px solid #0a1520;
  }
  .slider-row input[type=range]::-moz-range-thumb {
    width: 10px; height: 10px;
    border-radius: 50%;
    background: var(--val);
    cursor: pointer;
    border: 1px solid #0a1520;
  }

  .slider-val {
    font-size: 10px;
    color: var(--val);
    width: 36px;
    text-align: right;
    font-family: 'Share Tech Mono', monospace;
    flex-shrink: 0;
  }

  .radio-group {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }
  .radio-row {
    display: flex;
    align-items: center;
    gap: 7px;
    cursor: pointer;
    padding: 2px 4px;
    border-radius: 2px;
    transition: background 0.15s;
  }
  .radio-row:hover { background: var(--btn-hover); }
  .radio-row input[type=radio] { display: none; }
  .radio-dot {
    width: 9px; height: 9px;
    border-radius: 50%;
    border: 1px solid var(--val);
    flex-shrink: 0;
    display: flex; align-items: center; justify-content: center;
    transition: background 0.15s;
  }
  .radio-dot.active { background: #3fb8e8; border-color: #3fb8e8; }
  .radio-label { font-size: 11px; color: var(--label); }

  .btn-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 5px;
  }

  button {
    background: var(--panel);
    border: 1px solid var(--border);
    color: var(--label);
    font-family: 'Share Tech Mono', monospace;
    font-size: 9px;
    letter-spacing: 1px;
    padding: 6px 4px;
    border-radius: 2px;
    cursor: pointer;
    text-transform: uppercase;
    transition: background 0.15s, border-color 0.15s, color 0.15s;
    white-space: nowrap;
  }
  button:hover { background: var(--btn-hover); border-color: var(--accent); }
  button.active { background: #0d2535; border-color: var(--val); color: var(--val); }
  button.wall-mode  { border-color: var(--wall-col); color: var(--wall-col); }
  button.emit-mode  { border-color: var(--emit-col); color: var(--emit-col); }
  #draw-mode-btn { grid-column: 1 / -1; }

  #status {
    font-family: 'Share Tech Mono', monospace;
    font-size: 9px;
    color: #2a4a5a;
    letter-spacing: 0.5px;
    padding: 3px 0 0 0;
  }
  #fps-display {
    font-family: 'Share Tech Mono', monospace;
    font-size: 9px;
    color: #3a7a5a;
    letter-spacing: 0.5px;
  }
</style>
</head>
<body>

<div id="canvas-wrap">
  <div id="canvas-title">◈ Water Reflection Simulator &nbsp;<span id="fps-display"></span></div>
  <div id="canvas-container">
    <canvas id="sim-canvas"></canvas>
    <canvas id="overlay-canvas"></canvas>
  </div>
  <div id="hint">L-click: ripple &nbsp;|&nbsp; R-drag: draw &nbsp;|&nbsp; Drag ●: move light &nbsp;|&nbsp; Tilt/Az: 3D camera</div>
</div>

<div id="panel">

  <div class="panel-section">
    <div class="section-title">Camera</div>
    <div class="slider-row">
      <span class="slider-label">Tilt °</span>
      <input type="range" id="sl-tilt" min="0" max="70" value="0" step="1">
      <span class="slider-val" id="sv-tilt">0</span>
    </div>
    <div class="slider-row">
      <span class="slider-label">Azimuth °</span>
      <input type="range" id="sl-azimuth" min="0" max="360" value="30" step="1">
      <span class="slider-val" id="sv-azimuth">30</span>
    </div>
  </div>

  <div class="panel-section">
    <div class="section-title">Waves</div>
    <div class="slider-row">
      <span class="slider-label">Amplitude</span>
      <input type="range" id="sl-amplitude" min="1" max="100" value="30" step="1">
      <span class="slider-val" id="sv-amplitude">0.30</span>
    </div>
    <div class="slider-row">
      <span class="slider-label">Frequency</span>
      <input type="range" id="sl-frequency" min="5" max="60" value="20" step="1">
      <span class="slider-val" id="sv-frequency">2.0</span>
    </div>
    <div class="slider-row">
      <span class="slider-label">Wave Count</span>
      <input type="range" id="sl-wavecount" min="1" max="12" value="6" step="1">
      <span class="slider-val" id="sv-wavecount">6</span>
    </div>
  </div>

  <div class="panel-section">
    <div class="section-title">Lighting</div>
    <div class="slider-row">
      <span class="slider-label">Shininess</span>
      <input type="range" id="sl-shininess" min="2" max="120" value="30" step="1">
      <span class="slider-val" id="sv-shininess">30</span>
    </div>
    <div class="slider-row">
      <span class="slider-label">Light Ht</span>
      <input type="range" id="sl-lightheight" min="10" max="150" value="50" step="1">
      <span class="slider-val" id="sv-lightheight">5.0</span>
    </div>
    <div class="slider-row">
      <span class="slider-label">Color Temp</span>
      <input type="range" id="sl-colortemp" min="3000" max="12000" value="6500" step="100">
      <span class="slider-val" id="sv-colortemp">6500</span>
    </div>
    <div class="section-title" style="margin-top:8px">Light Type</div>
    <div class="radio-group">
      <label class="radio-row"><input type="radio" name="light" value="Point" checked><span class="radio-dot active"></span><span class="radio-label">Point</span></label>
      <label class="radio-row"><input type="radio" name="light" value="Line"><span class="radio-dot"></span><span class="radio-label">Line</span></label>
      <label class="radio-row"><input type="radio" name="light" value="Circle"><span class="radio-dot"></span><span class="radio-label">Circle</span></label>
    </div>
  </div>

  <div class="panel-section">
    <div class="section-title">Speed</div>
    <div class="radio-group">
      <label class="radio-row"><input type="radio" name="speed" value="1" checked><span class="radio-dot active"></span><span class="radio-label">1×</span></label>
      <label class="radio-row"><input type="radio" name="speed" value="2"><span class="radio-dot"></span><span class="radio-label">2×</span></label>
      <label class="radio-row"><input type="radio" name="speed" value="5"><span class="radio-dot"></span><span class="radio-label">5×</span></label>
      <label class="radio-row"><input type="radio" name="speed" value="20"><span class="radio-dot"></span><span class="radio-label">20×</span></label>
      <label class="radio-row"><input type="radio" name="speed" value="50"><span class="radio-dot"></span><span class="radio-label">50×</span></label>
    </div>
  </div>

  <div class="panel-section">
    <div class="section-title">Resolution</div>
    <div class="slider-row">
      <span class="slider-label">Grid Size</span>
      <input type="range" id="sl-resolution" min="64" max="1024" value="512" step="64">
      <span class="slider-val" id="sv-resolution">512</span>
    </div>
    <div style="font-size:9px;color:#2a4a5a;font-family:'Share Tech Mono',monospace;margin-top:2px">GPU — go high!</div>
  </div>

  <div class="panel-section">
    <div class="section-title">Controls</div>
    <div class="btn-grid">
      <button id="btn-waves" class="active">Waves: ON</button>
      <button id="btn-pause">Pause</button>
      <button id="btn-edges">Edges: REFLECT</button>
      <button id="btn-reset">Reset</button>
      <button id="draw-mode-btn" class="wall-mode">Draw: WALL</button>
    </div>
  </div>

  <div id="status">initializing webgl…</div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════════
//  STATE
// ═══════════════════════════════════════════════════════════════════
const VIEW = 5.0;
let GRID = 512;

const state = {
  amplitude:    0.30,
  frequency:    2.00,
  waveCount:    6,
  shininess:    30,
  lightHeight:  5.0,
  colorTemp:    6500,
  tilt:         0,
  azimuth:      30,
  paused:       false,
  time:         0,
  timeScale:    1,
  bgWaves:      true,
  openEdges:    false,
  drawMode:     'wall',
  lightType:    'Point',
  lightXY:      [2.0, 2.0],
  circleRadius: 3.0,
  lineAngle:    0.0,
};

// Wave components
let wDirs, wFreqs, wSpeeds, wAmps, wPhases;
function buildWaveComponents() {
  const n = Math.round(state.waveCount);
  wDirs = new Float32Array(n * 2);
  wFreqs = new Float32Array(n);
  wSpeeds = new Float32Array(n);
  wAmps = new Float32Array(n);
  wPhases = new Float32Array(n);
  let seed = 42;
  function rand() { seed = (seed * 1664525 + 1013904223) >>> 0; return seed / 0x100000000; }
  let wSum = 0;
  for (let i = 0; i < n; i++) {
    const base = (i / n) * Math.PI * 2;
    const angle = base + (rand() - 0.5) * 0.6;
    wDirs[i*2]   = Math.cos(angle);
    wDirs[i*2+1] = Math.sin(angle);
    wFreqs[i]    = state.frequency * (0.6 + rand() * 0.8);
    wSpeeds[i]   = 1.0 + rand();
    const w = 0.5 + rand() * 0.5;
    wAmps[i] = w; wSum += w;
    wPhases[i] = rand() * Math.PI * 2;
  }
  for (let i = 0; i < n; i++) wAmps[i] /= wSum;
}
buildWaveComponents();

// ═══════════════════════════════════════════════════════════════════
//  BACKEND DETECTION
// ═══════════════════════════════════════════════════════════════════
const canvas = document.getElementById('sim-canvas');
const overlayCanvas = document.getElementById('overlay-canvas');
const oc = overlayCanvas.getContext('2d');

// Try WebGL with float texture support
let gl = null, USE_WEBGL = false;
try {
  gl = canvas.getContext('webgl', { antialias: false, preserveDrawingBuffer: false, powerPreference: 'high-performance' });
  if (gl) {
    const extFloat = gl.getExtension('OES_texture_float');
    if (extFloat) {
      gl.getExtension('OES_texture_float_linear');
      USE_WEBGL = true;
    }
  }
} catch(e) {}

if (!USE_WEBGL) {
  // Fall back to 2D canvas, use a smaller default grid
  GRID = 220;
  document.getElementById('sl-resolution').max = 400;
  document.getElementById('sl-resolution').value = 220;
  document.getElementById('sv-resolution').textContent = 220;
  document.querySelector('#sl-resolution').closest('.panel-section')
    .querySelector('div:last-child').textContent = 'CPU mode — keep lower';
  document.getElementById('status').textContent = 'cpu mode (no webgl float)';
} else {
  document.getElementById('status').textContent = 'initializing webgl…';
}

// ═══════════════════════════════════════════════════════════════════
//  CPU FALLBACK ENGINE
// ═══════════════════════════════════════════════════════════════════
let cpu_h0, cpu_h1, cpu_vel, cpu_hPrev, cpu_obsMask, cpu_emitMask;
let cpu_imageData, cpu_pixBuf, cpu_ctx;

function cpu_initArrays() {
  const N = GRID * GRID;
  cpu_h0      = new Float32Array(N);
  cpu_h1      = new Float32Array(N);
  cpu_vel     = new Float32Array(N);
  cpu_hPrev   = new Float32Array(N);
  cpu_obsMask = new Uint8Array(N);
  cpu_emitMask= new Uint8Array(N);
}

function cpu_initCanvas() {
  if (!cpu_ctx) cpu_ctx = canvas.getContext('2d');
  if (imgW > 0 && imgH > 0) {
    cpu_imageData = cpu_ctx.createImageData(imgW, imgH);
    cpu_pixBuf = cpu_imageData.data;
  }
}

const CPU_TENSION = 0.22, CPU_DAMP = 0.993;

function cpu_stepPDE() {
  cpu_hPrev.set(cpu_h0);
  for (let r = 1; r < GRID-1; r++) {
    for (let c = 1; c < GRID-1; c++) {
      const i = r*GRID+c;
      if (cpu_obsMask[i]) { cpu_h1[i]=0; cpu_vel[i]=0; continue; }
      const lap = cpu_h0[(r-1)*GRID+c]+cpu_h0[(r+1)*GRID+c]+cpu_h0[r*GRID+(c-1)]+cpu_h0[r*GRID+(c+1)]-4*cpu_h0[i];
      cpu_vel[i] = (cpu_vel[i] + CPU_TENSION*lap)*CPU_DAMP;
      cpu_h1[i]  = cpu_h0[i] + cpu_vel[i];
    }
  }
  if (!state.openEdges) {
    for (let c=0;c<GRID;c++){cpu_h1[c]=0;cpu_h1[(GRID-1)*GRID+c]=0;cpu_vel[c]=0;cpu_vel[(GRID-1)*GRID+c]=0;}
    for (let r=0;r<GRID;r++){cpu_h1[r*GRID]=0;cpu_h1[r*GRID+GRID-1]=0;cpu_vel[r*GRID]=0;cpu_vel[r*GRID+GRID-1]=0;}
  } else {
    const cv=Math.sqrt(CPU_TENSION), ref=(cv-1)/(cv+1);
    for (let c=0;c<GRID;c++){
      cpu_h1[0*GRID+c]        =cpu_hPrev[1*GRID+c]+ref*(cpu_h1[1*GRID+c]-cpu_hPrev[0*GRID+c]);
      cpu_h1[(GRID-1)*GRID+c] =cpu_hPrev[(GRID-2)*GRID+c]+ref*(cpu_h1[(GRID-2)*GRID+c]-cpu_hPrev[(GRID-1)*GRID+c]);
    }
    for (let r=0;r<GRID;r++){
      cpu_h1[r*GRID]      =cpu_hPrev[r*GRID+1]+ref*(cpu_h1[r*GRID+1]-cpu_hPrev[r*GRID]);
      cpu_h1[r*GRID+GRID-1]=cpu_hPrev[r*GRID+GRID-2]+ref*(cpu_h1[r*GRID+GRID-2]-cpu_hPrev[r*GRID+GRID-1]);
    }
  }
  [cpu_h0, cpu_h1] = [cpu_h1, cpu_h0];
  const drive = 3.0*state.amplitude*Math.sin(2.5*state.time);
  for (let i=0;i<GRID*GRID;i++) if (cpu_emitMask[i]) { cpu_h0[i]=drive; cpu_vel[i]=0; }
}

function cpu_kelvinRGB(T) {
  T = Math.max(1000,Math.min(40000,T))/100;
  let R,G,B;
  if(T<=66){R=1;G=Math.max(0,Math.min(1,(99.47*Math.log(T)-161.12)/255));B=T<=19?0:Math.max(0,Math.min(1,(138.52*Math.log(T-10)-305.04)/255));}
  else{R=Math.max(0,Math.min(1,(329.7*Math.pow(T-60,-0.133))/255));G=Math.max(0,Math.min(1,(288.12*Math.pow(T-60,-0.076))/255));B=1;}
  return [R,G,B];
}

function cpu_render() {
  if (!cpu_ctx || !cpu_pixBuf) return;
  const n = Math.round(state.waveCount);
  const [lr,lg,lb] = cpu_kelvinRGB(state.colorTemp);
  const scaleX = imgW/GRID, scaleY = imgH/GRID;
  const lhVal = state.lightHeight;

  for (let r=0;r<GRID;r++) {
    for (let c=0;c<GRID;c++) {
      const i=r*GRID+c;
      const wx=-VIEW+(c/(GRID-1))*2*VIEW;
      const wy=-VIEW+(r/(GRID-1))*2*VIEW;
      let h = cpu_h0[i];
      if (state.bgWaves) {
        for (let wi=0;wi<n;wi++)
          h+=wAmps[wi]*state.amplitude*Math.sin(wFreqs[wi]*(wDirs[wi*2]*wx+wDirs[wi*2+1]*wy)-wSpeeds[wi]*state.time+wPhases[wi]);
      }
      let rr,gg,bb;
      if (cpu_obsMask[i]) { rr=90;gg=5;bb=5; }
      else if (cpu_emitMask[i]) {
        const t=Math.max(0,Math.min(1,cpu_h0[i]/Math.max(3*state.amplitude,1e-6)*0.5+0.5));
        rr=0;gg=Math.round((t*0.9+(1-t)*0.2)*255);bb=Math.round((t+(1-t)*0.4)*255);
      } else {
        const hl=c>0?cpu_h0[i-1]:h, hr2=c<GRID-1?cpu_h0[i+1]:h;
        const hu=r>0?cpu_h0[(r-1)*GRID+c]:h, hd=r<GRID-1?cpu_h0[(r+1)*GRID+c]:h;
        const sc=GRID/(2*VIEW);
        let nx=-(hr2-hl)*0.5*sc, ny=-(hd-hu)*0.5*sc, nz=1;
        const inv=1/Math.sqrt(nx*nx+ny*ny+nz*nz); nx*=inv;ny*=inv;nz*=inv;
        let lx,ly,lz,ldist;
        if(state.lightType==='Point'){lx=state.lightXY[0]-wx;ly=state.lightXY[1]-wy;lz=lhVal;}
        else if(state.lightType==='Line'){const ca=Math.cos(state.lineAngle),sa=Math.sin(state.lineAngle),tp=wx*ca+wy*sa;lx=tp*ca-wx;ly=tp*sa-wy;lz=lhVal;}
        else{const a=Math.atan2(wy,wx);lx=state.circleRadius*Math.cos(a)-wx;ly=state.circleRadius*Math.sin(a)-wy;lz=lhVal;}
        ldist=Math.max(1e-6,Math.sqrt(lx*lx+ly*ly+lz*lz));lx/=ldist;ly/=ldist;lz/=ldist;
        const NdotL=Math.max(0,nx*lx+ny*ly+nz*lz);
        const rx=2*NdotL*nx-lx,ry=2*NdotL*ny-ly,rz2=2*NdotL*nz-lz;
        const spec=Math.pow(Math.max(0,rx*0+ry*0+rz2*1),state.shininess); // simplified view=overhead
        const atten=1/(1+0.05*ldist*ldist);
        const lap=(hl+hr2+hu+hd-4*h);
        const caus=Math.pow(Math.max(0,Math.min(1,-lap*4)),2);
        const diff=NdotL*atten*0.30, sp=spec*atten*1.3, ca2=caus*0.45;
        const encode=v=>Math.round(Math.pow(Math.max(0,Math.min(1,v)),1/2.2)*255);
        rr=encode(0.01+diff+(sp+ca2)*lr);
        gg=encode(0.05+diff+(sp+ca2)*lg);
        bb=encode(0.16+diff+(sp+ca2)*lb);
      }
      // Write pixel block (scale grid to canvas)
      const px0=Math.round(c*scaleX), px1=Math.round((c+1)*scaleX);
      const py0=Math.round((GRID-1-r)*scaleY), py1=Math.round((GRID-r)*scaleY); // flip Y for display
      for (let py=py0;py<py1;py++) for (let px=px0;px<px1;px++) {
        if(px<0||px>=imgW||py<0||py>=imgH) continue;
        const bi=(py*imgW+px)*4;
        cpu_pixBuf[bi]=rr;cpu_pixBuf[bi+1]=gg;cpu_pixBuf[bi+2]=bb;cpu_pixBuf[bi+3]=255;
      }
    }
  }
  cpu_ctx.putImageData(cpu_imageData,0,0);
}

function cpu_addRipple(wx, wy) {
  const col=Math.floor((wx+VIEW)/(2*VIEW)*GRID);
  const row=Math.floor((wy+VIEW)/(2*VIEW)*GRID);
  const r=Math.max(2,Math.round(GRID/80));
  if(col<r+1||col>=GRID-r-1||row<r+1||row>=GRID-r-1) return;
  const s=3.0*state.amplitude;
  for(let dr=-r;dr<=r;dr++) for(let dc=-r;dc<=r;dc++) {
    if(dr*dr+dc*dc>r*r) continue;
    cpu_h0[(row+dr)*GRID+(col+dc)]+=s*(1-Math.sqrt(dr*dr+dc*dc)/(r+1));
  }
}

function cpu_commitShape(worldPts) {
  if(worldPts.length<2) return;
  const thickPx=Math.max(2,Math.round(GRID/150));
  const mask=cpu_rasterisePolyline(worldPts,thickPx);
  for(let i=0;i<GRID*GRID;i++) {
    if(!mask[i]) continue;
    if(state.drawMode==='wall'){cpu_obsMask[i]=1;cpu_emitMask[i]=0;cpu_h0[i]=0;cpu_vel[i]=0;}
    else{cpu_emitMask[i]=1;cpu_obsMask[i]=0;}
  }
}

function cpu_rasterisePolyline(worldPts,thickness) {
  const mask=new Uint8Array(GRID*GRID);
  function w2g(wx,wy){return[Math.max(0,Math.min(GRID-1,Math.floor((wx+VIEW)/(2*VIEW)*(GRID-1)))),Math.max(0,Math.min(GRID-1,Math.floor((wy+VIEW)/(2*VIEW)*(GRID-1))))];}
  function bresen(c0,r0,c1,r1,cb){let dc=Math.abs(c1-c0),dr=Math.abs(r1-r0);const sc=c1>c0?1:-1,sr=r1>r0?1:-1;let err=dc-dr;for(;;){cb(c0,r0);if(c0===c1&&r0===r1)break;const e2=2*err;if(e2>-dr){err-=dr;c0+=sc;}if(e2<dc){err+=dc;r0+=sr;}}}
  for(let i=0;i<worldPts.length-1;i++){const[c0,r0]=w2g(...worldPts[i]);const[c1,r1]=w2g(...worldPts[i+1]);bresen(c0,r0,c1,r1,(c,r)=>{for(let dr2=-thickness;dr2<=thickness;dr2++)for(let dc2=-thickness;dc2<=thickness;dc2++){const rc=Math.max(0,Math.min(GRID-1,r+dr2)),cc=Math.max(0,Math.min(GRID-1,c+dc2));mask[rc*GRID+cc]=1;}});}
  return mask;
}

function cpu_reset() {
  cpu_h0.fill(0);cpu_h1.fill(0);cpu_vel.fill(0);cpu_hPrev.fill(0);
  cpu_obsMask.fill(0);cpu_emitMask.fill(0);
}

// ═══════════════════════════════════════════════════════════════════
//  WEBGL SHADERS & HELPERS (defined always, only called when USE_WEBGL)
// ═══════════════════════════════════════════════════════════════════
let progPDE, progShade, progCopy, quadBuf;

function compileShader(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
    console.error(gl.getShaderInfoLog(s), src);
  return s;
}
function makeProgram(vsSrc, fsSrc) {
  const p = gl.createProgram();
  gl.attachShader(p, compileShader(gl.VERTEX_SHADER, vsSrc));
  gl.attachShader(p, compileShader(gl.FRAGMENT_SHADER, fsSrc));
  gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS))
    console.error(gl.getProgramInfoLog(p));
  return p;
}

// Full-screen quad
const quadVS = `
attribute vec2 a_pos;
varying vec2 v_uv;
void main() {
  v_uv = a_pos * 0.5 + 0.5;
  gl_Position = vec4(a_pos, 0.0, 1.0);
}`;

// ── PDE step shader ─────────────────────────────────────────────────
// Uses a single ping-pong pair: each texture stores r=h_current, g=h_previous
// So we only need ONE input texture and ONE output texture per step.
const pdeFS = `
precision highp float;
uniform sampler2D u_state; // r=h_curr, g=h_prev
uniform sampler2D u_mask;
uniform vec2  u_texel;
uniform float u_tension;
uniform float u_damp;
uniform float u_drive;
uniform int   u_openEdges;

varying vec2 v_uv;

void main() {
  vec2 uv = v_uv;
  vec4 mask = texture2D(u_mask, uv);
  if (mask.r > 0.5) { gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); return; }
  if (mask.g > 0.5) { gl_FragColor = vec4(u_drive, 0.0, 0.0, 1.0); return; }

  vec2 sc = texture2D(u_state, uv).rg;
  float hC = sc.r; // current
  float hP = sc.g; // previous

  float hL = texture2D(u_state, uv - vec2(u_texel.x, 0.0)).r;
  float hR = texture2D(u_state, uv + vec2(u_texel.x, 0.0)).r;
  float hU = texture2D(u_state, uv - vec2(0.0, u_texel.y)).r;
  float hD = texture2D(u_state, uv + vec2(0.0, u_texel.y)).r;

  if (texture2D(u_mask, uv - vec2(u_texel.x, 0.0)).r > 0.5) hL = 0.0;
  if (texture2D(u_mask, uv + vec2(u_texel.x, 0.0)).r > 0.5) hR = 0.0;
  if (texture2D(u_mask, uv - vec2(0.0, u_texel.y)).r > 0.5) hU = 0.0;
  if (texture2D(u_mask, uv + vec2(0.0, u_texel.y)).r > 0.5) hD = 0.0;

  float lap  = hL + hR + hU + hD - 4.0 * hC;
  // Correct wave equation: hNew = (2 - damp)*hC - (1 - damp)*hP + tension*lap
  float hNew = (2.0 - u_damp) * hC - (1.0 - u_damp) * hP + u_tension * lap;

  // Boundary conditions
  bool edgeX0 = uv.x < u_texel.x * 1.5;
  bool edgeX1 = uv.x > 1.0 - u_texel.x * 1.5;
  bool edgeY0 = uv.y < u_texel.y * 1.5;
  bool edgeY1 = uv.y > 1.0 - u_texel.y * 1.5;
  bool edge   = edgeX0 || edgeX1 || edgeY0 || edgeY1;

  if (edge) {
    if (u_openEdges == 1) {
      float cv  = sqrt(u_tension);
      float ref = (cv - 1.0) / (cv + 1.0);
      vec2 inner = uv;
      if      (edgeX0) inner = uv + vec2( u_texel.x, 0.0);
      else if (edgeX1) inner = uv - vec2( u_texel.x, 0.0);
      else if (edgeY0) inner = uv + vec2(0.0,  u_texel.y);
      else             inner = uv - vec2(0.0,  u_texel.y);
      float hCi = texture2D(u_state, inner).r;
      float hPi = texture2D(u_state, inner).g;
      hNew = hPi + ref * (hCi - hP);
    } else {
      hNew = 0.0;
    }
  }

  // Output: r=hNew (next current), g=hC (becomes next previous)
  gl_FragColor = vec4(hNew, hC, 0.0, 1.0);
}
`;

// ── Shading / render shader ─────────────────────────────────────────
const shadingFSFixed = `
precision highp float;
uniform sampler2D u_wave;
uniform sampler2D u_mask;
uniform vec2  u_texel;
uniform float u_amplitude;
uniform float u_shininess;
uniform float u_lightHeight;
uniform vec3  u_lightRGB;
uniform int   u_lightType;
uniform vec2  u_lightXY;
uniform float u_lineAngle;
uniform float u_circleRadius;
uniform float u_time;
uniform float u_tilt;
uniform float u_azimuth;
uniform int   u_bgWaves;
uniform int   u_waveCount;
uniform vec2  u_wDirs[12];
uniform float u_wFreqs[12];
uniform float u_wSpeeds[12];
uniform float u_wAmps[12];
uniform float u_wPhases[12];

const float VIEW = 5.0;
const float PI   = 3.14159265;

varying vec2 v_uv;

vec3 buildCamPos() {
  float tr = u_tilt    * PI / 180.0;
  float ar = u_azimuth * PI / 180.0;
  float d  = 18.0;
  return vec3(d*sin(tr)*sin(ar), -d*sin(tr)*cos(ar), d*cos(tr));
}

void main() {
  vec2 uv   = v_uv;
  vec4 mask = texture2D(u_mask, uv);
  float isObs  = step(0.5, mask.r);
  float isEmit = step(0.5, mask.g);
  vec2 world   = (uv * 2.0 - 1.0) * VIEW;

  // Wave heights
  float h  = texture2D(u_wave, uv).r;
  float hl = texture2D(u_wave, uv - vec2(u_texel.x, 0.0)).r;
  float hr = texture2D(u_wave, uv + vec2(u_texel.x, 0.0)).r;
  float hu = texture2D(u_wave, uv - vec2(0.0, u_texel.y)).r;
  float hd = texture2D(u_wave, uv + vec2(0.0, u_texel.y)).r;

  // Background Gerstner waves
  if (u_bgWaves == 1) {
    for (int i = 0; i < 12; i++) {
      if (i >= u_waveCount) break;
      float ph = u_wFreqs[i]*(u_wDirs[i].x*world.x + u_wDirs[i].y*world.y) - u_wSpeeds[i]*u_time + u_wPhases[i];
      h  += u_wAmps[i] * u_amplitude * sin(ph);
      float phl = u_wFreqs[i]*(u_wDirs[i].x*(world.x-u_texel.x*2.0*VIEW) + u_wDirs[i].y*world.y) - u_wSpeeds[i]*u_time + u_wPhases[i];
      float phr = u_wFreqs[i]*(u_wDirs[i].x*(world.x+u_texel.x*2.0*VIEW) + u_wDirs[i].y*world.y) - u_wSpeeds[i]*u_time + u_wPhases[i];
      float phu = u_wFreqs[i]*(u_wDirs[i].x*world.x + u_wDirs[i].y*(world.y-u_texel.y*2.0*VIEW)) - u_wSpeeds[i]*u_time + u_wPhases[i];
      float phd = u_wFreqs[i]*(u_wDirs[i].x*world.x + u_wDirs[i].y*(world.y+u_texel.y*2.0*VIEW)) - u_wSpeeds[i]*u_time + u_wPhases[i];
      hl += u_wAmps[i] * u_amplitude * sin(phl);
      hr += u_wAmps[i] * u_amplitude * sin(phr);
      hu += u_wAmps[i] * u_amplitude * sin(phu);
      hd += u_wAmps[i] * u_amplitude * sin(phd);
    }
  }

  // Normals
  float dzdx = (hr - hl) * 0.5 / (u_texel.x * 2.0 * VIEW);
  float dzdy = (hd - hu) * 0.5 / (u_texel.y * 2.0 * VIEW);
  vec3 N = normalize(vec3(-dzdx, -dzdy, 1.0));

  // Obstacle
  if (isObs > 0.5) {
    gl_FragColor = vec4(pow(vec3(0.35, 0.02, 0.02), vec3(1.0/2.2)), 1.0);
    return;
  }
  // Emitter
  if (isEmit > 0.5) {
    float t = clamp(h / max(3.0*u_amplitude, 0.001)*0.5+0.5, 0.0, 1.0);
    vec3 col = vec3(0.0, t*0.9+(1.0-t)*0.2, t+(1.0-t)*0.4);
    gl_FragColor = vec4(pow(col, vec3(1.0/2.2)), 1.0);
    return;
  }

  // Light
  vec3 L; float ldist;
  float lh = u_lightHeight;
  if (u_lightType == 0) {
    vec3 lv = vec3(u_lightXY, lh) - vec3(world, h);
    ldist = length(lv); L = lv/ldist;
  } else if (u_lightType == 1) {
    float ca=cos(u_lineAngle), sa=sin(u_lineAngle), tp=world.x*ca+world.y*sa;
    vec3 lv = vec3(tp*ca, tp*sa, lh) - vec3(world, h);
    ldist = length(lv); L = lv/ldist;
  } else {
    float a = atan(world.y, world.x);
    vec3 lv = vec3(u_circleRadius*cos(a), u_circleRadius*sin(a), lh) - vec3(world, h);
    ldist = length(lv); L = lv/ldist;
  }

  vec3  V     = normalize(buildCamPos() - vec3(world, h));
  float NdotL = max(dot(N, L), 0.0);
  float spec  = pow(max(dot(reflect(-L,N), V), 0.0), u_shininess);
  float atten = 1.0 / (1.0 + 0.05*ldist*ldist);
  float lap   = hl + hr + hu + hd - 4.0*h;
  float caus  = pow(clamp(-lap*4.0, 0.0, 1.0), 2.0);

  float diff = NdotL*atten*0.30;
  float sp   = spec*atten*1.3;
  float ca2  = caus*0.45;

  vec3 col = clamp(vec3(0.01,0.05,0.16) + vec3(diff) + (sp+ca2)*u_lightRGB, 0.0, 1.0);
  gl_FragColor = vec4(pow(col, vec3(1.0/2.2)), 1.0);
}
`;

// ── Copy-to-screen shader ───────────────────────────────────────────
const copyFS = `
precision mediump float;
uniform sampler2D u_tex;
varying vec2 v_uv;
void main() {
  gl_FragColor = texture2D(u_tex, v_uv);
}`;

function initGLPrograms() {
  progPDE    = makeProgram(quadVS, pdeFS);
  progShade  = makeProgram(quadVS, shadingFSFixed);
  progCopy   = makeProgram(quadVS, copyFS);
  quadBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
}

function bindQuad(prog) {
  const loc = gl.getAttribLocation(prog, 'a_pos');
  gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
}

let texA, texB, texMask, texShade, fbA, fbB, fbShade;
let texCurr, texPrev, fbCurr, fbPrev;
let maskData;
let FLOAT_TYPE = null;

function makeTexture(w, h, data, type, format) {
  const t = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, t);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texImage2D(gl.TEXTURE_2D, 0, format || gl.RGBA, w, h, 0, format || gl.RGBA, type || gl.UNSIGNED_BYTE, data || null);
  return t;
}

function makeFB(tex) {
  const fb = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  return fb;
}

function initGL() {
  FLOAT_TYPE = gl.FLOAT;
  if (texA)  gl.deleteTexture(texA);
  if (texB)  gl.deleteTexture(texB);
  if (texMask)  gl.deleteTexture(texMask);
  if (texShade) gl.deleteTexture(texShade);
  if (fbA)   gl.deleteFramebuffer(fbA);
  if (fbB)   gl.deleteFramebuffer(fbB);
  if (fbShade) gl.deleteFramebuffer(fbShade);

  maskData = new Uint8Array(GRID * GRID * 4);

  // Two float textures for ping-pong; each stores r=hCurr, g=hPrev
  texA     = makeTexture(GRID, GRID, null, gl.FLOAT, gl.RGBA);
  texB     = makeTexture(GRID, GRID, null, gl.FLOAT, gl.RGBA);
  texMask  = makeTexture(GRID, GRID, maskData, gl.UNSIGNED_BYTE, gl.RGBA);
  texShade = makeTexture(GRID, GRID, null, gl.UNSIGNED_BYTE, gl.RGBA);

  fbA     = makeFB(texA);
  fbB     = makeFB(texB);
  fbShade = makeFB(texShade);

  // Clear both PDE textures
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbA);
  gl.viewport(0,0,GRID,GRID); gl.clearColor(0,0,0,0); gl.clear(gl.COLOR_BUFFER_BIT);
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbB);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

  texCurr = texA; fbCurr = fbA;
  texPrev = texB; fbPrev = fbB;
}

// ── Uniform helpers ─────────────────────────────────────────────────
function setTex(prog, name, unit, tex) {
  gl.activeTexture(gl.TEXTURE0 + unit);
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.uniform1i(gl.getUniformLocation(prog, name), unit);
}
function u1f(prog, n, v)  { gl.uniform1f(gl.getUniformLocation(prog, n), v); }
function u1i(prog, n, v)  { gl.uniform1i(gl.getUniformLocation(prog, n), v); }
function u2f(prog, n, x, y) { gl.uniform2f(gl.getUniformLocation(prog, n), x, y); }
function u3f(prog, n, x, y, z) { gl.uniform3f(gl.getUniformLocation(prog, n), x, y, z); }
function u1b(prog, n, v)  { gl.uniform1i(gl.getUniformLocation(prog, n), v ? 1 : 0); }

function setWaveUniforms(prog) {
  const n = Math.round(state.waveCount);
  u1i(prog, 'u_waveCount', n);
  // Set arrays element by element (WebGL1 limitation)
  for (let i = 0; i < n && i < 12; i++) {
    gl.uniform2f(gl.getUniformLocation(prog, `u_wDirs[${i}]`),   wDirs[i*2], wDirs[i*2+1]);
    gl.uniform1f(gl.getUniformLocation(prog, `u_wFreqs[${i}]`),  wFreqs[i]);
    gl.uniform1f(gl.getUniformLocation(prog, `u_wSpeeds[${i}]`), wSpeeds[i]);
    gl.uniform1f(gl.getUniformLocation(prog, `u_wAmps[${i}]`),   wAmps[i]);
    gl.uniform1f(gl.getUniformLocation(prog, `u_wPhases[${i}]`), wPhases[i]);
  }
}

// ═══════════════════════════════════════════════════════════════════
//  GPU PDE STEP
// ═══════════════════════════════════════════════════════════════════
const TENSION = 0.22;
const DAMP    = 0.014; // energy loss per step

function stepPDE() {
  // Read texCurr (has r=hC, g=hP), write new state into fbPrev, then swap
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbPrev);
  gl.viewport(0, 0, GRID, GRID);
  gl.useProgram(progPDE);
  bindQuad(progPDE);

  setTex(progPDE, 'u_state', 0, texCurr);
  setTex(progPDE, 'u_mask',  1, texMask);

  u2f(progPDE, 'u_texel', 1/GRID, 1/GRID);
  u1f(progPDE, 'u_tension', TENSION);
  u1f(progPDE, 'u_damp', DAMP);
  u1f(progPDE, 'u_drive', 3.0 * state.amplitude * Math.sin(2.5 * state.time));
  u1i(progPDE, 'u_openEdges', state.openEdges ? 1 : 0);

  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

  // Swap: written result in fbPrev/texPrev becomes new curr
  [texCurr, texPrev] = [texPrev, texCurr];
  [fbCurr,  fbPrev]  = [fbPrev,  fbCurr];
}

// ═══════════════════════════════════════════════════════════════════
//  CANVAS RESIZE
// ═══════════════════════════════════════════════════════════════════
let imgW = 0, imgH = 0;

function resizeCanvas() {
  const rect = canvas.getBoundingClientRect();
  imgW = Math.floor(rect.width);
  imgH = Math.floor(rect.height);
  canvas.width  = imgW;
  canvas.height = imgH;
  overlayCanvas.width  = imgW;
  overlayCanvas.height = imgH;
  if (!USE_WEBGL && cpu_ctx) {
    cpu_imageData = cpu_ctx.createImageData(imgW, imgH);
    cpu_pixBuf = cpu_imageData.data;
  }
}

// ═══════════════════════════════════════════════════════════════════
//  KELVIN → RGB (JS, called once per frame)
// ═══════════════════════════════════════════════════════════════════
function kelvinRGB(T) {
  T = Math.max(1000, Math.min(40000, T)) / 100.0;
  let R, G, B;
  if (T <= 66) {
    R = 1.0;
    G = Math.max(0, Math.min(1, (99.47 * Math.log(T) - 161.12) / 255));
    B = T <= 19 ? 0.0 : Math.max(0, Math.min(1, (138.52 * Math.log(T-10) - 305.04) / 255));
  } else {
    R = Math.max(0, Math.min(1, (329.70 * Math.pow(T-60, -0.133)) / 255));
    G = Math.max(0, Math.min(1, (288.12 * Math.pow(T-60, -0.076)) / 255));
    B = 1.0;
  }
  return [R, G, B];
}

// ═══════════════════════════════════════════════════════════════════
//  MAIN RENDER
// ═══════════════════════════════════════════════════════════════════
function render() {
  const [lr, lg, lb] = kelvinRGB(state.colorTemp);

  gl.useProgram(progShade);
  bindQuad(progShade);

  // Render shading to fbShade
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbShade);
  gl.viewport(0, 0, GRID, GRID);

  setTex(progShade, 'u_wave', 0, texCurr);
  setTex(progShade, 'u_mask', 1, texMask);
  u2f(progShade, 'u_texel', 1/GRID, 1/GRID);
  u1f(progShade, 'u_amplitude', state.amplitude);
  u1f(progShade, 'u_shininess', state.shininess);
  u1f(progShade, 'u_lightHeight', state.lightHeight);
  u3f(progShade, 'u_lightRGB', lr, lg, lb);
  u1i(progShade, 'u_lightType',
      state.lightType === 'Point' ? 0 : state.lightType === 'Line' ? 1 : 2);
  u2f(progShade, 'u_lightXY', state.lightXY[0], state.lightXY[1]);
  u1f(progShade, 'u_lineAngle', state.lineAngle);
  u1f(progShade, 'u_circleRadius', state.circleRadius);
  u1f(progShade, 'u_time', state.time);
  u1f(progShade, 'u_tilt', state.tilt);
  u1f(progShade, 'u_azimuth', state.azimuth);
  u1b(progShade, 'u_bgWaves', state.bgWaves);
  setWaveUniforms(progShade);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

  // Blit shaded texture to screen
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0, 0, imgW, imgH);
  gl.useProgram(progCopy);
  bindQuad(progCopy);
  setTex(progCopy, 'u_tex', 0, texShade);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

// ═══════════════════════════════════════════════════════════════════
//  OVERLAY (drawn on 2D canvas on top)
// ═══════════════════════════════════════════════════════════════════
function drawOverlays() {
  oc.clearRect(0, 0, imgW, imgH);
  if (state.tilt >= 5) return;

  function w2img(wx, wy) {
    // world Y is +up, screen Y is +down
    return [(wx + VIEW) / (2*VIEW) * imgW, (1 - (wy + VIEW) / (2*VIEW)) * imgH];
  }

  oc.save();
  if (state.lightType === 'Point') {
    const [mx, my] = w2img(...state.lightXY);
    oc.beginPath(); oc.arc(mx, my, 5, 0, Math.PI*2);
    oc.fillStyle = '#ffe566'; oc.fill();
    oc.strokeStyle = '#ffffff'; oc.lineWidth = 1; oc.stroke();
  } else if (state.lightType === 'Line') {
    const len = 2*VIEW;
    const ca = Math.cos(state.lineAngle), sa = Math.sin(state.lineAngle);
    const [x0,y0] = w2img(-len*ca, -len*sa);
    const [x1,y1] = w2img( len*ca,  len*sa);
    oc.beginPath(); oc.moveTo(x0,y0); oc.lineTo(x1,y1);
    oc.strokeStyle = 'rgba(255,229,102,0.6)'; oc.lineWidth = 2.5; oc.stroke();
  } else {
    const [cx,cy] = w2img(0,0);
    const rPx = state.circleRadius / (2*VIEW) * imgW;
    oc.beginPath(); oc.arc(cx, cy, rPx, 0, Math.PI*2);
    oc.strokeStyle = 'rgba(255,229,102,0.6)'; oc.lineWidth = 2.5; oc.stroke();
  }

  if (drawing && drawPtsWorld.length >= 2) {
    oc.beginPath();
    oc.strokeStyle = state.drawMode === 'wall' ? '#ff0033' : '#00eeff';
    oc.lineWidth = 2; oc.lineCap = 'round';
    const [sx0, sy0] = w2img(...drawPtsWorld[0]);
    oc.moveTo(sx0, sy0);
    for (let i = 1; i < drawPtsWorld.length; i++) {
      const [sx, sy] = w2img(...drawPtsWorld[i]);
      oc.lineTo(sx, sy);
    }
    oc.stroke();
  }
  oc.restore();
}

// ═══════════════════════════════════════════════════════════════════
//  RIPPLE — patch the current height texture
// ═══════════════════════════════════════════════════════════════════
function addRipple(wx, wy) {
  const col = Math.floor((wx + VIEW) / (2*VIEW) * GRID);
  const row = Math.floor((wy + VIEW) / (2*VIEW) * GRID);
  const r = Math.max(2, Math.round(GRID / 80));
  if (col < r+1 || col >= GRID-r-1 || row < r+1 || row >= GRID-r-1) return;

  const x0 = Math.max(0, col - r - 1);
  const y0 = Math.max(0, row - r - 1);
  const pw  = Math.min(GRID, col + r + 2) - x0;
  const ph  = Math.min(GRID, row + r + 2) - y0;

  gl.bindFramebuffer(gl.FRAMEBUFFER, fbCurr);
  const patch = new Float32Array(pw * ph * 4);
  gl.readPixels(x0, y0, pw, ph, gl.RGBA, gl.FLOAT, patch);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

  const s = 3.0 * state.amplitude;
  for (let dr = -r; dr <= r; dr++) {
    for (let dc = -r; dc <= r; dc++) {
      if (dr*dr + dc*dc > r*r) continue;
      const pr = (row + dr) - y0;
      const pc = (col + dc) - x0;
      if (pr < 0 || pr >= ph || pc < 0 || pc >= pw) continue;
      const idx = (pr * pw + pc) * 4;
      patch[idx] += s * (1.0 - Math.sqrt(dr*dr+dc*dc) / (r + 1)); // add to r=hCurr
    }
  }

  gl.bindTexture(gl.TEXTURE_2D, texCurr);
  gl.texSubImage2D(gl.TEXTURE_2D, 0, x0, y0, pw, ph, gl.RGBA, gl.FLOAT, patch);
  gl.bindTexture(gl.TEXTURE_2D, null);
}

// ═══════════════════════════════════════════════════════════════════
//  MASK (walls / emitters) — CPU side, uploaded as RGBA u8 texture
// ═══════════════════════════════════════════════════════════════════
function uploadMask() {
  gl.bindTexture(gl.TEXTURE_2D, texMask);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, GRID, GRID, 0, gl.RGBA, gl.UNSIGNED_BYTE, maskData);
  gl.bindTexture(gl.TEXTURE_2D, null);
}

function clearMaskRegion(startIdx, count) {
  // Zero out cells in maskData
  for (let i = 0; i < count; i++) {
    const base = (startIdx + i) * 4;
    maskData[base] = maskData[base+1] = maskData[base+2] = maskData[base+3] = 0;
  }
}

// ── Rasterise polyline into maskData ──────────────────────────────
function rasterisePolyline(worldPts, thickness) {
  const mask = new Uint8Array(GRID * GRID);

  function w2g(wx, wy) {
    return [
      Math.max(0, Math.min(GRID-1, Math.floor((wx+VIEW)/(2*VIEW)*(GRID-1)))),
      Math.max(0, Math.min(GRID-1, Math.floor((wy+VIEW)/(2*VIEW)*(GRID-1))))
    ];
  }

  function bresenham(c0, r0, c1, r1, cb) {
    let dc = Math.abs(c1-c0), dr = Math.abs(r1-r0);
    const sc = c1>c0?1:-1, sr = r1>r0?1:-1;
    let err = dc - dr;
    while (true) {
      cb(c0, r0);
      if (c0===c1 && r0===r1) break;
      const e2 = 2*err;
      if (e2 > -dr) { err-=dr; c0+=sc; }
      if (e2 <  dc) { err+=dc; r0+=sr; }
    }
  }

  for (let i = 0; i < worldPts.length-1; i++) {
    const [c0,r0] = w2g(...worldPts[i]);
    const [c1,r1] = w2g(...worldPts[i+1]);
    bresenham(c0, r0, c1, r1, (c, r) => {
      for (let dr2 = -thickness; dr2 <= thickness; dr2++) {
        for (let dc2 = -thickness; dc2 <= thickness; dc2++) {
          const rc = Math.max(0, Math.min(GRID-1, r+dr2));
          const cc = Math.max(0, Math.min(GRID-1, c+dc2));
          mask[rc*GRID+cc] = 1;
        }
      }
    });
  }
  return mask;
}

function commitShape(worldPts) {
  if (worldPts.length < 2) return;
  if (USE_WEBGL) {
    const thickPx = Math.max(2, Math.round(GRID / 150));
    const m = rasterisePolyline(worldPts, thickPx);
    for (let i = 0; i < GRID*GRID; i++) {
      if (!m[i]) continue;
      if (state.drawMode === 'wall') {
        maskData[i*4]=255; maskData[i*4+1]=0; maskData[i*4+2]=0; maskData[i*4+3]=255;
      } else {
        maskData[i*4]=0; maskData[i*4+1]=255; maskData[i*4+2]=0; maskData[i*4+3]=255;
      }
    }
    uploadMask();
  } else {
    cpu_commitShape(worldPts);
  }
}

// ═══════════════════════════════════════════════════════════════════
//  MOUSE / TOUCH
// ═══════════════════════════════════════════════════════════════════
let drawing       = false;
let drawPtsWorld  = [];
let draggingLight = false;

function canvasToWorld(ex, ey) {
  const rect = canvas.getBoundingClientRect();
  const px = ex - rect.left;
  const py = ey - rect.top;
  const wx = (px / rect.width)  * 2 * VIEW - VIEW;
  // Negate Y: canvas Y=0 is top, but GL textures and our world coords have Y=0 at bottom
  const wy = -((py / rect.height) * 2 * VIEW - VIEW);
  return [wx, wy];
}

function nearLight(wx, wy) {
  if (state.tilt > 5) return false;
  if (state.lightType === 'Point') {
    const dx = wx - state.lightXY[0], dy = wy - state.lightXY[1];
    return dx*dx + dy*dy < 0.4;
  } else if (state.lightType === 'Line') {
    return Math.abs(wy) < 0.3;
  } else {
    return Math.abs(Math.sqrt(wx*wx+wy*wy) - state.circleRadius) < 0.3;
  }
}

canvas.addEventListener('contextmenu', e => e.preventDefault());

canvas.addEventListener('mousedown', e => {
  e.preventDefault();
  const [wx, wy] = canvasToWorld(e.clientX, e.clientY);
  if (e.button === 2) {
    drawing = true;
    drawPtsWorld = [[wx, wy]];
  } else if (e.button === 0) {
    if (nearLight(wx, wy)) {
      draggingLight = true;
    } else if (state.tilt < 1.0) {
      if (USE_WEBGL) addRipple(wx, wy); else cpu_addRipple(wx, wy);
    }
  }
});

canvas.addEventListener('mousemove', e => {
  const [wx, wy] = canvasToWorld(e.clientX, e.clientY);
  if (drawing) {
    if (drawPtsWorld.length > 0) {
      const [lx, ly] = drawPtsWorld[drawPtsWorld.length-1];
      if ((wx-lx)**2 + (wy-ly)**2 > 0.0025) drawPtsWorld.push([wx, wy]);
    } else {
      drawPtsWorld.push([wx, wy]);
    }
  }
  if (draggingLight) {
    if (state.lightType === 'Point') state.lightXY = [wx, wy];
    else if (state.lightType === 'Line') state.lineAngle = Math.atan2(wy, wx);
    else state.circleRadius = Math.sqrt(wx*wx + wy*wy);
  }
});

canvas.addEventListener('mouseup', e => {
  if (e.button === 2 && drawing) {
    drawing = false;
    if (drawPtsWorld.length >= 2) commitShape(drawPtsWorld);
    drawPtsWorld = [];
  } else if (e.button === 0) {
    draggingLight = false;
  }
});

canvas.addEventListener('mouseleave', () => {
  if (drawing) {
    if (drawPtsWorld.length >= 2) commitShape(drawPtsWorld);
    drawPtsWorld = [];
    drawing = false;
  }
  draggingLight = false;
});

// ═══════════════════════════════════════════════════════════════════
//  ANIMATION LOOP + FPS
// ═══════════════════════════════════════════════════════════════════
let lastFpsTime = performance.now();
let frameCount = 0;

function loop() {
  if (!state.paused) {
    state.time += 0.04 * state.timeScale;
    const steps = Math.max(1, Math.min(Math.round(state.timeScale), 20));
    for (let s = 0; s < steps; s++) {
      if (USE_WEBGL) stepPDE(); else cpu_stepPDE();
    }
  }

  if (USE_WEBGL) { render(); drawOverlays(); }
  else           { cpu_render(); drawOverlays(); }

  frameCount++;
  const now = performance.now();
  if (now - lastFpsTime > 500) {
    const fps = (frameCount / ((now - lastFpsTime) / 1000)).toFixed(0);
    document.getElementById('fps-display').textContent =
      `${fps} fps · ${GRID}² · ${USE_WEBGL ? 'GPU' : 'CPU'}`;
    frameCount = 0;
    lastFpsTime = now;
  }

  requestAnimationFrame(loop);
}

// ═══════════════════════════════════════════════════════════════════
//  UI WIRING
// ═══════════════════════════════════════════════════════════════════
function wireSlider(id, valId, getter, setter, display) {
  const sl = document.getElementById(id);
  const vl = document.getElementById(valId);
  sl.addEventListener('input', () => {
    setter(parseFloat(sl.value));
    vl.textContent = display(parseFloat(sl.value));
  });
  vl.textContent = display(getter());
}

wireSlider('sl-tilt',       'sv-tilt',       ()=>state.tilt,      v=>{state.tilt=v;},                    v=>`${v}`);
wireSlider('sl-azimuth',    'sv-azimuth',    ()=>state.azimuth,   v=>{state.azimuth=v;},                 v=>`${v}`);
wireSlider('sl-amplitude',  'sv-amplitude',  ()=>30,              v=>{state.amplitude=v/100;},            v=>(v/100).toFixed(2));
wireSlider('sl-frequency',  'sv-frequency',  ()=>20,              v=>{state.frequency=v/10; buildWaveComponents();}, v=>(v/10).toFixed(1));
wireSlider('sl-wavecount',  'sv-wavecount',  ()=>6,               v=>{state.waveCount=v; buildWaveComponents();},   v=>`${v}`);
wireSlider('sl-shininess',  'sv-shininess',  ()=>30,              v=>{state.shininess=v;},                v=>`${v}`);
wireSlider('sl-lightheight','sv-lightheight',()=>50,              v=>{state.lightHeight=v/10;},           v=>(v/10).toFixed(1));
wireSlider('sl-colortemp',  'sv-colortemp',  ()=>6500,            v=>{state.colorTemp=v;},                v=>`${Math.round(v)}`);

(function() {
  const sl = document.getElementById('sl-resolution');
  const vl = document.getElementById('sv-resolution');
  sl.addEventListener('change', () => {
    GRID = parseInt(sl.value, 10);
    vl.textContent = GRID;
    if (USE_WEBGL) { initGL(); }
    else { cpu_initArrays(); cpu_initCanvas(); }
    buildWaveComponents();
    state.time = 0;
  });
  vl.textContent = GRID;
})();

function wireRadioGroup(name, onchange) {
  document.querySelectorAll(`input[name="${name}"]`).forEach(inp => {
    inp.addEventListener('change', () => {
      document.querySelectorAll(`input[name="${name}"]`).forEach(r =>
        r.closest('.radio-row').querySelector('.radio-dot').classList.toggle('active', r.checked));
      onchange(inp.value);
    });
  });
}

wireRadioGroup('light', val => { state.lightType = val; });
wireRadioGroup('speed', val => { state.timeScale = parseFloat(val); });

document.getElementById('btn-waves').addEventListener('click', function() {
  state.bgWaves = !state.bgWaves;
  this.textContent = state.bgWaves ? 'Waves: ON' : 'Waves: OFF';
  this.classList.toggle('active', state.bgWaves);
});

document.getElementById('btn-pause').addEventListener('click', function() {
  state.paused = !state.paused;
  this.textContent = state.paused ? 'Resume' : 'Pause';
  this.classList.toggle('active', state.paused);
});

document.getElementById('btn-edges').addEventListener('click', function() {
  state.openEdges = !state.openEdges;
  this.textContent = state.openEdges ? 'Edges: ABSORB' : 'Edges: REFLECT';
  this.classList.toggle('active', state.openEdges);
});

document.getElementById('btn-reset').addEventListener('click', () => {
  if (USE_WEBGL) {
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbA);
    gl.viewport(0,0,GRID,GRID); gl.clearColor(0,0,0,0); gl.clear(gl.COLOR_BUFFER_BIT);
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbB);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    texCurr = texA; texPrev = texB; fbCurr = fbA; fbPrev = fbB;
    maskData.fill(0); uploadMask();
  } else {
    cpu_reset();
  }
  state.lightXY = [2.0, 2.0];
  state.tilt = 0; state.azimuth = 30; state.time = 0;
  document.getElementById('sl-tilt').value = 0;       document.getElementById('sv-tilt').textContent = '0';
  document.getElementById('sl-azimuth').value = 30;   document.getElementById('sv-azimuth').textContent = '30';
  document.getElementById('sl-amplitude').value = 30; document.getElementById('sv-amplitude').textContent = '0.30';
  document.getElementById('sl-frequency').value = 20; document.getElementById('sv-frequency').textContent = '2.0';
  document.getElementById('sl-wavecount').value = 6;  document.getElementById('sv-wavecount').textContent = '6';
  document.getElementById('sl-shininess').value = 30; document.getElementById('sv-shininess').textContent = '30';
  document.getElementById('sl-lightheight').value=50; document.getElementById('sv-lightheight').textContent='5.0';
  document.getElementById('sl-colortemp').value=6500; document.getElementById('sv-colortemp').textContent='6500';
  state.amplitude=0.30; state.frequency=2.0; state.waveCount=6;
  state.shininess=30; state.lightHeight=5.0; state.colorTemp=6500;
  buildWaveComponents();
});

document.getElementById('draw-mode-btn').addEventListener('click', function() {
  state.drawMode = state.drawMode === 'wall' ? 'emitter' : 'wall';
  this.textContent = state.drawMode === 'wall' ? 'Draw: WALL' : 'Draw: EMITTER';
  this.className   = state.drawMode === 'wall' ? 'wall-mode' : 'emit-mode';
});

// ═══════════════════════════════════════════════════════════════════
//  RESIZE OBSERVER + START
// ═══════════════════════════════════════════════════════════════════
new ResizeObserver(() => resizeCanvas()).observe(canvas);

window.addEventListener('load', () => {
  resizeCanvas();
  if (USE_WEBGL) {
    initGLPrograms();
    initGL();
    document.getElementById('status').textContent = 'webgl active';
  } else {
    cpu_initArrays();
    cpu_initCanvas();
    document.getElementById('status').textContent = 'cpu mode';
  }
  loop();
});
</script>
</body>
</html>
